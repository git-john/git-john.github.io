<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农人生</title>
  
  <subtitle>技术博客，随笔，技术沉淀总结</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.readytran.com/"/>
  <updated>2019-03-21T15:12:35.628Z</updated>
  <id>http://blog.readytran.com/</id>
  
  <author>
    <name>John KANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interview</title>
    <link href="http://blog.readytran.com/2019/03/21/interview/"/>
    <id>http://blog.readytran.com/2019/03/21/interview/</id>
    <published>2019-03-21T12:59:07.000Z</published>
    <updated>2019-03-21T15:12:35.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>拷问： 自我介绍</p></blockquote><blockquote><p>拷问： 谈谈你对jvm的理解</p></blockquote><blockquote><p>拷问： 谈谈你对tcp/ip协议的理解</p></blockquote><blockquote><p>拷问： 谈谈你对并发编程的理解</p></blockquote><blockquote><p>拷问： 怎么对系统进行调优<br>jvm参数配置<br>操作系统配置</p></blockquote><p><a href="https://blog.csdn.net/sinat_35512245" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35512245</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;拷问： 自我介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;拷问： 谈谈你对jvm的理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;拷问： 谈谈你对tcp/ip协议的理解&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="interview" scheme="http://blog.readytran.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>读书</title>
    <link href="http://blog.readytran.com/2019/03/21/%E8%AF%BB%E4%B9%A6/"/>
    <id>http://blog.readytran.com/2019/03/21/读书/</id>
    <published>2019-03-21T09:33:12.000Z</published>
    <updated>2019-03-21T09:56:32.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><p>已读的书</p><blockquote><p>《曾国藩传》</p></blockquote><p>读后感： 以前学习历史的时候，对曾国藩可以说是相当鄙视的，被太平天国打的几次要跳水自杀。读完这本书发现，他比左宗棠还伟大。他本身并不聪明，记忆力很差（比我差远了），身体也不行。但是他一直在致力于做圣人的目标， 为了达成这样的目标，他想尽办法，每天都读书，写日志反省自己。 他提出尚拙的理念，其实就是要自己将基础夯实。很认可他的书要一本一本的读，读完一本再去读下一本的理念。 看完后给自己立下目标，不再想尽办法去搜集下载书，将计划要读的书读好了再去读下一本书，让自己不再浮躁。博客要坚持写下去， 让自己学会思考，而不是一直在接受别人的想法中。 学习曾国藩的为人信条： 不因谄媚而去夸奖，因为那会让你的夸奖显得廉价，让别人对你的夸奖不在乎，如果我每次都是发自内心的夸奖，那么我的夸奖就会让人觉得很开心。</p><blockquote><p>《sed与awk》</p></blockquote><p>偏实操的书，读到后面，难度有点大，走马观花的读完没有去验证，等以后补上吧。 </p><p>计划读的书</p><blockquote><p>《人类简史》</p></blockquote><blockquote><p>《人月神话》</p></blockquote><blockquote><p>《深入理解jvm虚拟机》</p></blockquote><blockquote><p>《spring内幕》</p></blockquote><blockquote><p>《阿里java开发手册》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019&quot;&gt;&lt;a href=&quot;#2019&quot; class=&quot;headerlink&quot; title=&quot;2019&quot;&gt;&lt;/a&gt;2019&lt;/h1&gt;&lt;p&gt;已读的书&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《曾国藩传》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读后感： 以前学习
      
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.readytran.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于并发</title>
    <link href="http://blog.readytran.com/2019/03/21/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/"/>
    <id>http://blog.readytran.com/2019/03/21/关于并发/</id>
    <published>2019-03-21T03:48:53.000Z</published>
    <updated>2019-03-21T03:51:48.660Z</updated>
    
    <content type="html"><![CDATA[<p>我的并发有多少， 每个请求20ms左右。 那么我的平均响应时间=0.02， qps=50，两台服务器，就是一秒有100qps。<br>我能支撑的并发是多少呢，一个小时的并发支撑能力为 100*3600=36w.那么我的系统就是百万级别的并发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的并发有多少， 每个请求20ms左右。 那么我的平均响应时间=0.02， qps=50，两台服务器，就是一秒有100qps。&lt;br&gt;我能支撑的并发是多少呢，一个小时的并发支撑能力为 100*3600=36w.那么我的系统就是百万级别的并发。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="架构" scheme="http://blog.readytran.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>awk与sed读书笔记</title>
    <link href="http://blog.readytran.com/2019/03/15/awk%E4%B8%8Esed%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.readytran.com/2019/03/15/awk与sed读书笔记/</id>
    <published>2019-03-15T08:49:21.000Z</published>
    <updated>2019-03-19T10:06:22.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是awk，sed"><a href="#什么是awk，sed" class="headerlink" title="什么是awk，sed"></a>什么是awk，sed</h1><ul><li>sed是一个面向字符流的编辑器</li><li>awk是模式匹配的程序设计语言</li></ul><p>#能做什么</p><ul><li>sed</li></ul><ol><li>在一个或多个文件上自动实现编辑操作</li><li>简化对多个文件执行相同的编辑处理工作</li><li>编写转换程序</li></ol><ul><li>awk</li></ul><ol><li>更容易处理多个数据流</li><li>定义函数</li><li>使用字符串和算术操作符</li><li>处理unix命令结果</li></ol><p>#怎么做</p><blockquote><p>示例文本内容</p></blockquote><p>list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">John Daggett, 341 King Road, Plymouth MA</span><br><span class="line"></span><br><span class="line">Alice Ford, 22 EAST Broadway, Richmond VA</span><br><span class="line"></span><br><span class="line">Orville Thomas, 11345 Oak Bridge Road, Tulsa OK</span><br><span class="line"></span><br><span class="line">Terry Kalkas, 402 Lans Road, Beaver Falls PA</span><br><span class="line"></span><br><span class="line">Eric Adams, 20 Post Road, Sudbury MA</span><br><span class="line"></span><br><span class="line">Hubert Sims, 328A Brook Road, Roanoke VA</span><br><span class="line"></span><br><span class="line">Amy Wilde, 334 Bayshore Pkwy, Mountain View CA</span><br><span class="line"></span><br><span class="line">Sal Carpenter, 73 6th Street, Boston MA</span><br></pre></td></tr></table></figure></p><p>namestate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s/MA/,massachsetts/</span><br><span class="line">s/CA/,california/</span><br><span class="line">s/OK/,OkLaHema/</span><br><span class="line">s/PA/,Penssyvalian/</span><br></pre></td></tr></table></figure></p><ul><li>sed用法示例，更多用法使用<code>sed --help</code>查看</li></ul><p>使用命令执行匹配与替换，多个命令用分号隔开: <code>sed -e &#39;s/MA/mmmaaa/;s/VA/vvvaaa/&#39; list</code></p><p>对list文件执行命令脚本: <code>sed -f script list</code></p><p>阻止自动输出每个输入行，使用-n（要生成输出的地方，需要带上打印命令P）: <code>sed -n &#39;s/MA/mmaaa/p&#39; list</code></p><ul><li>awk用法示例</li></ul><p>查询包含MA的行： <code>awk &#39;/MA/&#39; list</code></p><p>查询第一个单词（分隔符默认为空格）： <code>awk &#39;print ${1}&#39; list</code></p><p>查询包含MA的行，并打印第一个单词： <code>awk &#39;/MA/{print $1}&#39; list</code></p><p>将单词分隔符指定为逗号并查询包含MA的行，并打印第一个单词：<code>awk -F, &#39;/MA/{print $1}&#39; list</code></p><ul><li>同时使用sed与awk示例：</li></ul><p>查询满足namestate文件规则的行，分隔符指定为逗号，第四个单词：<code>sed -f namestate list | awk -F, &#39;{print $4}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是awk，sed&quot;&gt;&lt;a href=&quot;#什么是awk，sed&quot; class=&quot;headerlink&quot; title=&quot;什么是awk，sed&quot;&gt;&lt;/a&gt;什么是awk，sed&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;sed是一个面向字符流的编辑器&lt;/li&gt;
&lt;li&gt;awk是模式匹
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记</title>
    <link href="http://blog.readytran.com/2019/03/11/docker%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.readytran.com/2019/03/11/docker笔记/</id>
    <published>2019-03-11T07:11:56.000Z</published>
    <updated>2019-03-11T07:18:21.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>开源应用容器引擎。开发人员可以打包应用以及依赖包到这样一个容器中，然后发布到任意的linux主机系统。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>基于go语言开发，基于linux的cgroup，namespace以及AUFS类的union FS技术对进程进行隔离。最初实现是基于linux的LXC容器，后来转为自己研发的containerd和runC</p><h3 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h3><p>docker使用C/S架构模式，通过api来管理docker容器。</p><ul><li>docker镜像：创建docker容器的模板</li><li>docker容器：独立运行的一个或者一组应用</li><li>docker client：用于调用docker api的命令行工具或者其他工具</li><li>docker主机：物理或虚拟的主机，用来运行docker守护进程或者docker容器</li><li>docker仓库：用于存放docker镜像的仓库</li><li>docker machine：安装与配置docker的工具，主要作用是在多主机情况下一个个的去安装比较麻烦，用docker-machine可以远程管理安装配置公章</li></ul><p><img src="../asset/img/docker-system.png" alt="hexo image"></p><h3 id="centos7安装"><a href="#centos7安装" class="headerlink" title="centos7安装"></a>centos7安装</h3><h4 id="检查内核版本"><a href="#检查内核版本" class="headerlink" title="检查内核版本"></a>检查内核版本</h4><p>检查linux内核版本是否满足，需要3.10以上的内核版本才能安装docker。</p><blockquote><p>uname -r</p></blockquote><h4 id="移除旧版本"><a href="#移除旧版本" class="headerlink" title="移除旧版本"></a>移除旧版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p>安装系统依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>添加软件源</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ol start="3"><li>更新yum缓存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><ol start="4"><li>安装docker-ce（社区版）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><ol start="5"><li>启动docker</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><ol start="6"><li>测试运行hello world</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><ol start="7"><li>镜像加速</li></ol><p>由于国内网络连接国外网络比较慢，因此需要配置加速器，加速地址使用163的仓库地址。 编辑  /etc/docker/daemon.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="docker资源"><a href="#docker资源" class="headerlink" title="docker资源"></a>docker资源</h3><h4 id="Docker官方英文资源"><a href="#Docker官方英文资源" class="headerlink" title="Docker官方英文资源"></a>Docker官方英文资源</h4><ul><li>docker官网：<a href="http://www.docker.com" target="_blank" rel="noopener">http://www.docker.com</a></li><li></li><li>Docker Windows 入门：<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/</a></li><li></li><li>Docker CE(社区版) Ubuntu：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></li><li>Docker mac 入门：<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/</a></li><li>Docker 用户指引：<a href="https://docs.docker.com/config/daemon/" target="_blank" rel="noopener">https://docs.docker.com/config/daemon/</a></li><li>Docker 官方博客：<a href="http://blog.docker.com/" target="_blank" rel="noopener">http://blog.docker.com/</a></li><li>Docker Hub: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></li><li>Docker开源： <a href="https://www.docker.com/open-source" target="_blank" rel="noopener">https://www.docker.com/open-source</a></li></ul><h4 id="Docker中文资源"><a href="#Docker中文资源" class="headerlink" title="Docker中文资源"></a>Docker中文资源</h4><ul><li>Docker中文网站：<a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a></li><li>Docker安装手册：<a href="https://docs.docker-cn.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker-cn.com/engine/installation/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h3&gt;&lt;p&gt;开源应用容器引擎。开发人员可以打包应用以及依赖包到这样一个容器中，然后发布到任意的linux主机系统。&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://blog.readytran.com/2019/03/11/iptables/"/>
    <id>http://blog.readytran.com/2019/03/11/iptables/</id>
    <published>2019-03-11T01:55:31.000Z</published>
    <updated>2019-03-11T02:10:29.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>公司的防攻击策略主要是通过iptables进行数据包转发，将真实服务器隐藏在一堆非业务主机后面，这样服务器被攻击的时候，只需要更换服务器ip，将被攻击的服务器丢入废弃池就好，而不需要重新搭建部署服务器。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A PREROUTING -t nat -i eth1 -p tcp --dport 3030 -j DNAT --to 10.51.18.147:3030 </span><br><span class="line">iptables -t nat -A POSTROUTING -d 10.51.18.147 -p tcp --dport 3030 -j MASQUERADE</span><br><span class="line">iptables -A PREROUTING -t nat -i eth1 -p tcp --dport 3309 -j DNAT --to 10.51.18.147:3309</span><br><span class="line">iptables -t nat -A POSTROUTING -d 10.51.18.147 -p tcp --dport 3309 -j MASQUERADE</span><br><span class="line">iptables -A PREROUTING -t nat -i eth1 -p tcp --dport 3310 -j DNAT --to 10.51.18.147:3310</span><br><span class="line">iptables -t nat -A POSTROUTING -d 10.51.18.147 -p tcp --dport 3310 -j MASQUERADE</span><br></pre></td></tr></table></figure></p><h1 id="iptables详解"><a href="#iptables详解" class="headerlink" title="iptables详解"></a>iptables详解</h1><h2 id="iptables基础"><a href="#iptables基础" class="headerlink" title="iptables基础"></a>iptables基础</h2><p>iptables规则为预定义的条件，当数据包包头符合条件时候，按规则来处理数据包。规则存储在内核空间信息包过滤表中。这些规则分别指定了源地址，目标地址，传输协议（tcp,udp,icmp等）和服务类型（如http，ftp，smtp等）当数据包与规则匹配时候，iptables根据规则定义的方法处理（accept，reject，drop）</p><h2 id="iptables和netfilter的关系"><a href="#iptables和netfilter的关系" class="headerlink" title="iptables和netfilter的关系"></a>iptables和netfilter的关系</h2><p>iptables只是防火墙的管理工具，netfilter是功能实现</p><h2 id="iptables传输数据包过程"><a href="#iptables传输数据包过程" class="headerlink" title="iptables传输数据包过程"></a>iptables传输数据包过程</h2><ol><li>当一个数据包进入网卡时，首先进入prerouting，内核根据数据包目的IP判断是否要转发出去</li><li>如果数据包是进入本机的，就会向下走，进入input链，这个时候所有进程都可以收到数据包。本机进程发送数据时会进入output链，进入postrouting链输出</li><li>如果数据包是要转发出去，数据包就会如图向右移动，进入forward链，到达postrouting链输出</li></ol><p><img src="../asset/img/iptables.png" alt="hexo image"></p><p>参考链接：<br><a href="https://www.jianshu.com/p/ee4ee15d3658" target="_blank" rel="noopener">https://www.jianshu.com/p/ee4ee15d3658</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;公司的防攻击策略主要是通过iptables进行数据包转发，将真实服务器隐藏在一堆非业务主机后面，这样服务器被攻击的时候，只需要更换服务器ip
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>理解redis字符串类型</title>
    <link href="http://blog.readytran.com/2019/03/05/%E7%90%86%E8%A7%A3redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.readytran.com/2019/03/05/理解redis字符串类型/</id>
    <published>2019-03-05T02:19:59.000Z</published>
    <updated>2019-03-11T08:12:52.948Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5b6b88e5e51d45191d7a4a13" target="_blank" rel="noopener">https://juejin.im/post/5b6b88e5e51d45191d7a4a13</a><br><a href="https://segmentfault.com/a/1190000014397497" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014397497</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b6b88e5e51d45191d7a4a13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5b6b88e5e51d45191d7a4a13&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解java垃圾回收</title>
    <link href="http://blog.readytran.com/2019/03/03/%E7%90%86%E8%A7%A3java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://blog.readytran.com/2019/03/03/理解java垃圾回收/</id>
    <published>2019-03-03T02:17:26.000Z</published>
    <updated>2019-03-21T09:55:32.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>java垃圾回收一直是各大面试官重点考察对象，如果连java垃圾回收都不理解的话， 是不能称为懂Java的。我虽然工作这么多年，也了解java垃圾回收，但是由于平时调优工作少，也不能很流畅的叙述出来。 这篇笔记通过查阅资料，以实操的方式来理解java内存回收机制。</p><h1 id="常用调优操作"><a href="#常用调优操作" class="headerlink" title="常用调优操作"></a>常用调优操作</h1><p>#相关术语</p><ul><li>CMS垃圾收集算法</li><li>ParNew垃圾收集算法</li><li>minorGC</li><li>fullGC</li><li>老年代</li><li>新生代</li><li>eden</li><li>survivor</li><li>stop the world</li></ul><hr><ul><li><a href="https://segmentfault.com/a/1190000004233812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004233812</a></li><li><a href="https://blog.csdn.net/wh211212/article/details/80437696" target="_blank" rel="noopener">https://blog.csdn.net/wh211212/article/details/80437696</a></li><li><a href="https://segmentfault.com/a/1190000004233812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004233812</a></li><li><a href="https://mp.weixin.qq.com/s/MCp16GDT0T0IVwRas6oNcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MCp16GDT0T0IVwRas6oNcA</a></li><li><a href="https://blog.51cto.com/andrewli/2130346" target="_blank" rel="noopener">https://blog.51cto.com/andrewli/2130346</a></li><li><a href="https://segmentfault.com/a/1190000010844969" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010844969</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我的理解&quot;&gt;&lt;a href=&quot;#我的理解&quot; class=&quot;headerlink&quot; title=&quot;我的理解&quot;&gt;&lt;/a&gt;我的理解&lt;/h1&gt;&lt;p&gt;java垃圾回收一直是各大面试官重点考察对象，如果连java垃圾回收都不理解的话， 是不能称为懂Java的。我虽然工作这么多
      
    
    </summary>
    
    
      <category term="java" scheme="http://blog.readytran.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>江影工作总结</title>
    <link href="http://blog.readytran.com/2019/03/01/%E6%B1%9F%E5%BD%B1%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.readytran.com/2019/03/01/江影工作总结/</id>
    <published>2019-03-01T08:15:37.000Z</published>
    <updated>2019-03-21T15:57:14.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近总是很焦虑， 对工作很焦虑，对公司发展焦虑，对个人的发展焦虑。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><ul><li>后台管理系统</li></ul><p>来到公司后的第一件事情就是让给公司做一个监控管理平台，参考友盟后台弄，问我多长时间能弄好，我基本上没犹豫就说一周差不多就能弄好，因为我之前也做过一些管理系统，开发相对简单。后来的结果是我用django+easyui做了一个后台管理系统，只满足了能够查询用户注册数据，用户充值数据，注册和充值统计报表功能。根据后来我慢慢了解到的需求，原来我是需要做一个插件给游戏客户端，用来收集留存，活跃等数据信息。一个后台系统，用来查看管理这些数据信息。这个系统做的很失败，一开始就做错了。现在回顾分析下来，主要有几点原因：<a id="more"></a></p><ol><li>我并没有做过游戏行业，将这个管理后台当成了一般的crud功能性的后台</li><li>没有一个很好的需求说明，自始至终都是让参考友盟，不知道如何下手 </li><li>一开始在需求丝毫不知的情况下，毫无业务了解的情况下夸下了海口，导致后续朝简单的方面去思考</li></ol><p>以上几点原因有人的性格问题，有公司的制度原因，后来几年一直围绕后台打口水战，一直被鄙视，而我一直是不服气的。按结果导向来说，我是失败了，希望以此为鉴。如果再发生此种场景应如何呢？ 首先不要急于去表现，了解清楚情况后再立下承诺。其次，多加沟通，沟通多了别人就会知道进度情况，沟通多了自然就可以对项目的把控，对需求的理解更加深刻。</p><hr><ul><li>接口服务</li></ul><p>在公司做的第二件事情就是接手游戏服务接口设计开发。我最感兴趣的就是这块了。当时来公司的时候写了三年python，觉得python写起来很舒服，技术选型就选了python，框架使用了django+redis，采用uwsgi+nginx部署。这个接口系统在前期没有注意并发情况，导致出现了刷金币的恶劣事件，后面就一直很稳定了，并发能力也高，高到什么程度呢：每秒可以支撑同时在线用户上万，百万级别不成问题，并发安全使用了redis锁来处理分布式并发，完全满足了游戏接口处理能力。</p><ul><li>直播系统</li></ul><p>公司当时还是很能赚钱的，一年能有8000万的流水不是开玩笑的。于是公司就找了一个小团队做直播，种种原因之下，决定将直播接手过来自己开发。于是我和另外一个小伙伴两个人开始了直播的网站开发，直播的手机端接口开发，接口文档。我充当了项目经理加技术主管加高级开发的角色。每天都要打很多电话和深圳团队（客户端）沟通接口需求，要催进度，要研究直播流程（当时完全不懂怎么玩）。经过了大量加班，把原来的网站（php）改造成了springmvc+mybatis+freemarker架构的直播网站。flash工程没改好，socket服务器没有改动，http接口改好了。 推流拉流都很熟悉了。存储过程全面了解了。算是一个半成品吧。 过程很痛苦，当时游戏的业务很大，总共两个人，又要做游戏活动，又要研究开发直播系统。结果也是很痛，只能算半成品。 因为flash那块是直接拿过来用，客户端连接的socket端是c#开发。本想着用netty改造掉socket服务端，上头不允许，理由是不信任我们。<br>直播系统推广以后，要做各种活动，我们没有ui，只有美术出了psd图，为了这个psd图转成活动页面，我在加班一天无果后，在技术群出100块钱找了一个在校生完成。特意记录这个事情，是觉得很有意思，我自掏腰包弄的。</p><ul><li>汽车app</li></ul><p>公司管理层的又一个拍脑袋作品， 团队里面一个小伙子设计开发的，采用mui做前端，springmvc+mybatis作为后端接口开发。我在里面的角色是前期项目管理，需求沟通。</p><ul><li>爱好圈</li></ul><p>由于微信对红包群的封杀，导致房卡类游戏没法进行开展，决定自研一个聊天兼具红包功能的app。我负责项目数据库设计，需求分析后传达到团队并分配任务（项目经理+架构师？），部分开发任务。 采用了pb数据传输协议，springmvc+mybatis作为技术后端。</p><ul><li>房卡app</li></ul><p>给房卡游戏提供支撑的一个app， 主要用户为游戏代理。我负责部分后端接口开发任务，后期负责ios的app维护开发。一开始是网页形式，后来要形成app，我提出使用cordova进行加壳，既快速也方便维护。只可惜后来因为一个dns劫持的问题（我觉得主要原因可能是老板对深圳开发人员闲置的一个资源利用）</p><hr><h1 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h1><ul><li>来到这个公司后， 公司的技术比较陈旧，仍然在使用struts1. 老板秉承的是能用至上原则，所以基本上在公司没学习到什么新技术，也没有积累到可以吹嘘的资本。</li><li>公司主要靠游戏赚钱， 我做的工作属于偏外围的工作， 非常忙碌，感觉身体跨了不少。忙碌也让我觉得自己很有价值，没有去思考未来，思考自己的职业。</li><li>我在公司的贡献：推动了部分新技术，如使用了mybatis替换之前用的jdbctemplate，最大的好处是可以自动生成代码，减少了工作量。采用了jekeins进行应用部署， 推动公司代码仓库使用git， 推动springboot的应用，编写了很多自动化python脚本， 如：机器人生成脚本，定期清理日志脚本，进程监控脚本。</li></ul><blockquote><p>以上几点可以看出， 这段工作经历对我的职业发展不太有利， 既没有参与核心业务，也没有技术上的成长。不知道现在明白是否还来得及？ 很焦虑！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近总是很焦虑， 对工作很焦虑，对公司发展焦虑，对个人的发展焦虑。&lt;/p&gt;
&lt;h1 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;后台管理系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来到公司后的第一件事情就是让给公司做一个监控管理平台，参考友盟后台弄，问我多长时间能弄好，我基本上没犹豫就说一周差不多就能弄好，因为我之前也做过一些管理系统，开发相对简单。后来的结果是我用django+easyui做了一个后台管理系统，只满足了能够查询用户注册数据，用户充值数据，注册和充值统计报表功能。根据后来我慢慢了解到的需求，原来我是需要做一个插件给游戏客户端，用来收集留存，活跃等数据信息。一个后台系统，用来查看管理这些数据信息。这个系统做的很失败，一开始就做错了。现在回顾分析下来，主要有几点原因：
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.readytran.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>ios开发者帐号</title>
    <link href="http://blog.readytran.com/2019/02/28/ios%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%90%E5%8F%B7/"/>
    <id>http://blog.readytran.com/2019/02/28/ios开发者帐号/</id>
    <published>2019-02-28T08:40:37.000Z</published>
    <updated>2019-02-28T09:23:42.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Certificates，Identifiers-amp-Profiles"><a href="#Certificates，Identifiers-amp-Profiles" class="headerlink" title="Certificates，Identifiers &amp; Profiles"></a>Certificates，Identifiers &amp; Profiles</h3><p>对于刚学ios开发的人来说，最先需要掌握的就是苹果开发的Certificates，Identifiers &amp; Profiles.<br><img src="../asset/img/ios_developer.png" alt="hexo image"></p><h4 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h4><p>这就是证书，需要从mac上生成后上传到开发平台,生成方法：</p><blockquote><p>钥匙串访问 -&gt; 证书助理 -&gt; 从证书颁发机构请求证书… -&gt; 保存到本地</p></blockquote><p>这个证书生成后会有一个文件，上传到developer后台。 如果其他电脑上需要用到这个证书，需要从生成证书的mac导出证书，目的是为了将私钥导过来。</p><h4 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h4><p>生成appid， ios应用app的全球唯一标识符。在xcode工程中为工程的bundleid。</p><h4 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h4><p>这货就是描述文件了，每个app对应一个开发者描述文件和发布版本描述文件。 生成描述文件的时候，如果开发者帐号为企业版本，选择in-house，商城包选择 store。 描述文件对应的证书可以是相同的. 所以证书一般只生成一个开发者证书，一个发布证书即可啦</p><hr><p>以上为我的个人使用总结，如需要了解原理，了解更多，网上资料大把可以参考如下链接（写完后觉得写的浅显后搜索的）<br><a href="https://www.cnblogs.com/xiaofeixiang/p/4564585.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaofeixiang/p/4564585.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Certificates，Identifiers-amp-Profiles&quot;&gt;&lt;a href=&quot;#Certificates，Identifiers-amp-Profiles&quot; class=&quot;headerlink&quot; title=&quot;Certificates，Ident
      
    
    </summary>
    
    
      <category term="ios" scheme="http://blog.readytran.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>三次握手四次挥手</title>
    <link href="http://blog.readytran.com/2019/02/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://blog.readytran.com/2019/02/28/三次握手四次挥手/</id>
    <published>2019-02-28T08:35:49.000Z</published>
    <updated>2019-02-28T09:28:55.570Z</updated>
    
    <content type="html"><![CDATA[<p>常用查询linux服务器性能的一个命令，查询服务器请求连接状态，这个命令会列出请求的状态以及对应的请求个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure><ul><li>TIME_WAIT 28 #表示主动关闭，通过优化系统内核参数可容易解决</li><li>CLOSE_WAIT 1 #表示被动关闭，需要从程序本身出发</li><li>ESTABLISHED 30 #表示正在通信</li></ul><hr><blockquote><p>要了解这个命令产生的结果，需要了解tcp的三次握手，四次挥手. 三次握手是为了建立连接，四次挥手是为了断开连接<br><a id="more"></a></p></blockquote><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>client端发送请求报文：syn=1,seq=client_sn</li><li>Server接收到请求报文后进行第一次握手并进行资源分配，回复报文：syn=1，seq=server_sn,ack=client_sn+1</li><li>客户端收到server的回复后，进行第二次握手并进行资源分配，回复：syn=0，seq=client_sn+1,ack=server_sn+1</li><li>Server收到客户端的ack报文后为第三次握手，表示连接成功建立</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>断开连接，可以是服务器断开，也可以是客户端断开。<br>客户端主动断开连接的情况如下：</p><ol><li>客户端发送fin,进入fin_wait状态，表示：客户端没有数据要发给server，请求关闭 （第一次挥手）</li><li>服务端收到fin后，发送ack，说：请求已收到，我还没准备好，请等待。此时连接状态在服务器端为close_wait状态，（第二次挥手） 而客户端进入FIN_wait2状态。</li><li>服务器确认准备好了以后，发送fin给客户端，表示：准备好关闭。（第三次挥手）</li><li>客户端收到FIN后，发送ack给服务端，自身进入time_wait状态。如果server没有收到ack则可以重传 （第四次挥手）</li><li>服务端收到ack后，知道可以关闭，不再回复消息</li><li>客户端等待2MSL后，确认没有收到消息，把连接中断<br><img src="/asset/img/client_1.png" alt="hexo image"><br><img src="/asset/img/server_1.png" alt="hexo image"></li></ol><hr><p>看了上面的情况，大概知道这几个状态的数据是怎么形成的了，以下是解决方案：</p><blockquote><p>通过修改/etc/sysctl.conf文件，服务器能够快速回收和重用TIME_WAIT 的资源</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1  #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭         </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1  #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭    </span><br><span class="line">net.ipv4.tcp_fin_timeout=30 #表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间</span><br></pre></td></tr></table></figure><blockquote><p>导致 CLOSE_WAIT 大量存在的原因：就是在对方关闭连接之后服务器程序自己没有进一步发出 ACK 信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着；服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。</p></blockquote><p>解决方案：代码需要判断 socket ，一旦读到 0，断开连接，read 返回负，检查一下 errno，如果不是 AGAIN，就断开连接。<br>所以解决 CLOSE_WAIT 大量存在的方法还是从自身的代码出发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用查询linux服务器性能的一个命令，查询服务器请求连接状态，这个命令会列出请求的状态以及对应的请求个数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat -n | awk &amp;apos;/^tcp/ &amp;#123;++S[$NF]&amp;#125; END &amp;#123;for(a in S) print a, S[a]&amp;#125;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;TIME_WAIT 28 #表示主动关闭，通过优化系统内核参数可容易解决&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT 1 #表示被动关闭，需要从程序本身出发&lt;/li&gt;
&lt;li&gt;ESTABLISHED 30 #表示正在通信&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;要了解这个命令产生的结果，需要了解tcp的三次握手，四次挥手. 三次握手是为了建立连接，四次挥手是为了断开连接&lt;br&gt;
    
    </summary>
    
    
      <category term="tcp" scheme="http://blog.readytran.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>lsyncd多目录同步</title>
    <link href="http://blog.readytran.com/2019/02/19/lsyncd%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.readytran.com/2019/02/19/lsyncd安装与配置/</id>
    <published>2019-02-19T08:02:38.000Z</published>
    <updated>2019-02-19T09:15:25.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装lsyncd"><a href="#安装lsyncd" class="headerlink" title="安装lsyncd"></a>安装lsyncd</h3><blockquote><p>lsyncd即Live Syncing Daemon，它是开源的数据实时同步工具(后台进程)，基于Linux2.6.3以后的inotify机制和rsync，安装方法如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y lsyncd lua lua-devel</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="lsyncd设置"><a href="#lsyncd设置" class="headerlink" title="lsyncd设置"></a>lsyncd设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">-- global setting</span><br><span class="line">---------------------------------------------------------------------------------settings</span><br><span class="line"></span><br><span class="line">settings&#123;</span><br><span class="line">        logfile         = &quot;/data/var/log/lsyncd/lsyncd.log&quot;,</span><br><span class="line">        statusFile      = &quot;/data/var/log/lsyncd/lsyncd.status&quot;,</span><br><span class="line">        inotifyMode     = &quot;CloseWrite&quot;,</span><br><span class="line">        maxProcesses    = 7</span><br><span class="line">        -- nodaemon     =true,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------settings</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------define</span><br><span class="line">-- host list，要同步的服务器列表</span><br><span class="line">servers = &#123;</span><br><span class="line">    &quot;xx.xx.xx.xx&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- directory list </span><br><span class="line">dirpath = &#123;</span><br><span class="line">&quot;/data/www&quot;,</span><br><span class="line">&quot;/data/cmd&quot;,</span><br><span class="line">&quot;/data/local/tomcat8/conf&quot;,</span><br><span class="line">&quot;/data/local/nginx/conf&quot;,</span><br><span class="line">&quot;/etc/rsyslog.d&quot;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------define</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------action</span><br><span class="line">for _, srvip in ipairs(servers) do</span><br><span class="line">for _, dir in ipairs(dirpath) do</span><br><span class="line"></span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source= dir,</span><br><span class="line">    target= &quot;webguest@&quot;..srvip..&quot;:&quot;..dir,</span><br><span class="line">    maxDelays= 5,</span><br><span class="line">    delay= 30,</span><br><span class="line">    exclude= &#123;&quot;*.tmp&quot;,&quot;Catalina&quot;&#125;,</span><br><span class="line">    rsync= &#123;</span><br><span class="line">binary          = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">archive         = true,</span><br><span class="line">compress        = true,</span><br><span class="line">-- bwlimit         = 2000,</span><br><span class="line">rsh             = &quot;/usr/bin/ssh -p 10062 -o StrictHostKeyChecking=no -l webguest -i /home/webguest/.ssh/id_rsa_slb&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">---------------------------------------------------------------------------------action</span><br></pre></td></tr></table></figure><blockquote><p>以上实现的是通过shell脚本循环逻辑来做多目录的同步， 也可以简单的使用多个sync配置多个目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source= /data/www/xxdir,</span><br><span class="line">    target= &quot;webguest@xx.xx.xx.xx:/data/www/xxdir,</span><br><span class="line">    maxDelays= 5,</span><br><span class="line">    delay= 30,</span><br><span class="line">    exclude= &#123;&quot;*.tmp&quot;,&quot;Catalina&quot;&#125;,</span><br><span class="line">    rsync= &#123;</span><br><span class="line">binary          = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">archive         = true,</span><br><span class="line">compress        = true,</span><br><span class="line">-- bwlimit         = 2000,</span><br><span class="line">rsh             = &quot;/usr/bin/ssh -p 10062 -o StrictHostKeyChecking=no -l webguest -i id_rsa&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source= /data/www/xxdir2,</span><br><span class="line">    target= &quot;webguest@xx.xx.xx.xx:/data/www/xxdir2,</span><br><span class="line">    maxDelays= 5,</span><br><span class="line">    delay= 30,</span><br><span class="line">    exclude= &#123;&quot;*.tmp&quot;,&quot;Catalina&quot;&#125;,</span><br><span class="line">    rsync= &#123;</span><br><span class="line">binary          = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">archive         = true,</span><br><span class="line">compress        = true,</span><br><span class="line">-- bwlimit         = 2000,</span><br><span class="line">rsh             = &quot;/usr/bin/ssh -p 10062 -o StrictHostKeyChecking=no -l webguest -i id_rsa&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://klionsec.github.io/2017/11/18/lsyncd/#menu" target="_blank" rel="noopener">https://klionsec.github.io/2017/11/18/lsyncd/#menu</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装lsyncd&quot;&gt;&lt;a href=&quot;#安装lsyncd&quot; class=&quot;headerlink&quot; title=&quot;安装lsyncd&quot;&gt;&lt;/a&gt;安装lsyncd&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;lsyncd即Live Syncing Daemon，它是开源的数据实时同步工具(后台进程)，基于Linux2.6.3以后的inotify机制和rsync，安装方法如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install -y lsyncd lua lua-devel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mac,xcode快捷键大全</title>
    <link href="http://blog.readytran.com/2019/02/19/mac-xcode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>http://blog.readytran.com/2019/02/19/mac-xcode快捷键大全/</id>
    <published>2019-02-19T07:49:35.000Z</published>
    <updated>2019-02-19T07:57:52.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mac文本操作"><a href="#mac文本操作" class="headerlink" title="mac文本操作"></a>mac文本操作</h3><ul><li>delete 向后删除</li><li>Fn+delete 向前删除</li><li>撤销： Command-z</li><li>回退：shift+command+z</li><li>剪切：command + x</li><li>copy：command + c</li><li>粘贴：command + v</li><li>全选：command + a</li><li>保存：command + s</li><li>查找：command + f<a id="more"></a></li><li>截取选中区域并保存到文件：command + shift + 4</li><li>截取全部屏幕并保存到文件：command + shift + 3</li><li>截取全部屏幕到剪贴板： command + shift + control + 3</li><li>打开强制退出窗口：command + option + esc</li><li>fn-上箭头 向上滚动一页（Page Up）</li><li>fn-下箭头 向下滚动一页（Page Down）　　</li><li>fn-左箭头 滚动至文稿开头（Home）　　</li><li>fn-右箭头 滚动至文稿末尾（End）　　</li><li>Command-右箭头 将光标移至当前行的行尾　　</li><li>Command-左箭头 将光标移至当前行的行首　　</li><li>Command-下箭头 将光标移至文稿末尾　　</li><li>Command-上箭头 将光标移至文稿开头　　</li><li>Option-右箭头 将光标移至下一个单词的末尾　　</li><li>Option-左箭头 将光标移至上一个单词的开头　　</li><li>Control-A 移至行或段落的开头</li></ul><h4 id="在Finder中："><a href="#在Finder中：" class="headerlink" title="在Finder中："></a>在Finder中：</h4><ul><li>Command-Option-V 剪切文件　　</li><li>Command-Shift-N 新建文件夹（New）　　　</li><li>Command-上箭头 打开包含当前文件夹的文件夹，相当于Windows里的“向上”　　</li><li>Command-Delete 将文件移至废纸篓　　</li><li>Command-Shift-Delete 清倒废纸篓　　</li><li>空格键 快速查看选中的文件，也就是预览功能</li></ul><h3 id="xcode调试"><a href="#xcode调试" class="headerlink" title="xcode调试"></a>xcode调试</h3><ul><li>运行与停止<blockquote><p>运行：command + r. 停止： command</p></blockquote></li><li>调试<blockquote><p>F6单步调试 | F7进入方法 | F8继续</p></blockquote></li></ul><h3 id="mac键盘符号图例"><a href="#mac键盘符号图例" class="headerlink" title="mac键盘符号图例"></a>mac键盘符号图例</h3><p><img src="../asset/img/mac_keyboard.jpg" alt="hexo image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mac文本操作&quot;&gt;&lt;a href=&quot;#mac文本操作&quot; class=&quot;headerlink&quot; title=&quot;mac文本操作&quot;&gt;&lt;/a&gt;mac文本操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;delete 向后删除&lt;/li&gt;
&lt;li&gt;Fn+delete 向前删除&lt;/li&gt;
&lt;li&gt;撤销： Command-z&lt;/li&gt;
&lt;li&gt;回退：shift+command+z&lt;/li&gt;
&lt;li&gt;剪切：command + x&lt;/li&gt;
&lt;li&gt;copy：command + c&lt;/li&gt;
&lt;li&gt;粘贴：command + v&lt;/li&gt;
&lt;li&gt;全选：command + a&lt;/li&gt;
&lt;li&gt;保存：command + s&lt;/li&gt;
&lt;li&gt;查找：command + f
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
      <category term="工具" scheme="http://blog.readytran.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://blog.readytran.com/2019/02/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.readytran.com/2019/02/18/git常用命令/</id>
    <published>2019-02-18T09:01:31.000Z</published>
    <updated>2019-02-18T09:06:36.739Z</updated>
    
    <content type="html"><![CDATA[<ol><li>查看当前没有add 的内容修改</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><ol start="2"><li>查看已经add，没有commit的改动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="3"><li>查看当前没有add，没有commit的改动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff head </span><br><span class="line">或者 </span><br><span class="line">git status</span><br></pre></td></tr></table></figure><ol start="4"><li>查看任意两个版本之间的改动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 版本号码1 版本号码2</span><br></pre></td></tr></table></figure><ol start="5"><li>比较两个版本号码的src 文件夹的差异</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 版本号码1 版本号码2  src</span><br></pre></td></tr></table></figure><ol start="6"><li>删除git上的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt</span><br></pre></td></tr></table></figure><blockquote><p>如果误删了本地test.txt想要从版本库还原到本地</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --test.txt</span><br></pre></td></tr></table></figure><ol start="7"><li>查看git历史提交（commit）记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">加上 --pretty=online 参数可以使得信息更简洁</span><br><span class="line">即：git log --pretty=online</span><br></pre></td></tr></table></figure><ol start="8"><li>版本穿梭</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. git reset --hard HEAD^</span><br><span class="line">git中当前版本用HEAD表示，^表示上一个版本。</span><br><span class="line">两个^^表示上上个版本，往上100个版本，就是100个^，</span><br><span class="line">也可以写成HEAD~100.也可以直接使用提交的commitid来回穿梭。</span><br><span class="line">2. git reflog查看命令历史. git log查看提交历史</span><br><span class="line">3. git log查看提交历史</span><br><span class="line">4.git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）</span><br><span class="line">5.git diff --cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别</span><br></pre></td></tr></table></figure><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><hr><h4 id="git-pull-vs-git-fetch-vs-git-remote-update"><a href="#git-pull-vs-git-fetch-vs-git-remote-update" class="headerlink" title="git pull vs git fetch vs git remote update"></a>git pull vs git fetch vs git remote update</h4><hr><ul><li>git remote update will update all of your branches set to track remote ones, but not merge any changes in.</li><li>git fetch will update only the branch you’re on, but not merge any changes in.</li><li>git pull will update and merge any remote changes of the current branch you’re on. This would be the one you use to update a local branch.</li></ul><h2 id="Command-line-instructions"><a href="#Command-line-instructions" class="headerlink" title="Command line instructions"></a>Command line instructions</h2><ul><li>Git global setup</li><li>git config –global user.name “康强”</li><li>git config –global user.email “<a href="mailto:kangqiang@k3k.com" target="_blank" rel="noopener">kangqiang@k3k.com</a>“</li></ul><h3 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h3><ul><li>git clone ssh:<a href="mailto://git@gd.k3k.com" target="_blank" rel="noopener">//git@gd.k3k.com</a>:13303/kangqiang/ios_aihaoquan.git</li><li>cd ios_aihaoquan</li><li>touch README.md</li><li>git add README.md</li><li>git commit -m “add README”</li><li>git push -u origin master</li></ul><h3 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h3><ul><li>cd existing_folder</li><li>git init</li><li>git remote add origin ssh:<a href="mailto://git@gd.k3k.com" target="_blank" rel="noopener">//git@gd.k3k.com</a>:13303/kangqiang/ios_aihaoquan.git</li><li>git add .</li><li>git commit -m “Initial commit”</li><li>git push -u origin master</li></ul><h3 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h3><ul><li>cd existing_repo</li><li>git remote rename origin old-origin</li><li>git remote add origin ssh:<a href="mailto://git@gd.k3k.com" target="_blank" rel="noopener">//git@gd.k3k.com</a>:13303/kangqiang/ios_aihaoquan.git</li><li>git push -u origin –all</li><li>git push -u origin –tags</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kancloud.cn/xiak/github/218507" target="_blank" rel="noopener">https://www.kancloud.cn/xiak/github/218507</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li><li><a href="https://learngitbranching.js.org/?demo" target="_blank" rel="noopener">https://learngitbranching.js.org/?demo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;查看当前没有add 的内容修改&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git diff&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;查看已经add，没有commit的改动&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git diff --cached&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.readytran.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>定时任务检测进程</title>
    <link href="http://blog.readytran.com/2019/02/18/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A3%80%E6%B5%8B%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.readytran.com/2019/02/18/定时任务检测进程/</id>
    <published>2019-02-18T08:59:18.000Z</published>
    <updated>2019-02-18T08:59:57.387Z</updated>
    
    <content type="html"><![CDATA[<h6 id="php网站总是无法访问，重启php-fpm进程后可以访问。"><a href="#php网站总是无法访问，重启php-fpm进程后可以访问。" class="headerlink" title="php网站总是无法访问，重启php-fpm进程后可以访问。"></a><p>php网站总是无法访问，重启php-fpm进程后可以访问。</p></h6><p>为了避免麻烦,写了个守护进程监控，当发现端口无法telnet后，杀掉进程重启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#check php-fpm server up/down</span><br><span class="line">TelLog=/home/xcguest/telphp.log</span><br><span class="line">/usr/bin/telnet 127.0.0.1 9000 &lt;&lt; ! &gt; $TelLog</span><br><span class="line">quit</span><br><span class="line">!</span><br><span class="line">SOK=`cat $TelLog | grep &quot;Escape character&quot; |wc -l`</span><br><span class="line">if [ $SOK -eq 1 ];then</span><br><span class="line">  echo &quot;php-fpm is ok&quot;</span><br><span class="line">else</span><br><span class="line">  killall -9 php-fpm</span><br><span class="line">  sleep 1</span><br><span class="line">  /usr/local/php/sbin/php-fpm</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><ol><li>保存为php_monitor.sh后；</li><li>执行chmod +x 使得脚本拥有执行权限。</li><li>执行crontab -e， 添加定时脚本每分钟检查一次<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * /home/xcguest/php_check.sh</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;php网站总是无法访问，重启php-fpm进程后可以访问。&quot;&gt;&lt;a href=&quot;#php网站总是无法访问，重启php-fpm进程后可以访问。&quot; class=&quot;headerlink&quot; title=&quot;php网站总是无法访问，重启php-fpm进程后可以访问。&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
      <category term="工具" scheme="http://blog.readytran.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="http://blog.readytran.com/2019/02/18/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://blog.readytran.com/2019/02/18/科学上网/</id>
    <published>2019-02-18T08:37:10.000Z</published>
    <updated>2019-02-18T08:43:58.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>centos 6.65</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>安装python： <blockquote><p>yum install python-setuptools</p></blockquote></li><li>安装wget：<blockquote><p>yum install wget</p></blockquote></li><li>安装pip：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate</span><br><span class="line">tar -xzvf pip-1.3.1.tar.gz</span><br><span class="line">cd pip-1.3.1</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li></ul><p>也可直接使用 easy_install pip</p><a id="more"></a><ul><li>安装shadowsocks <blockquote><p>pip install shadowsocks</p></blockquote></li></ul><h4 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h4><blockquote><p>vi /etc/shadowsocks.json</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;: 1080,</span><br><span class="line">    &quot;server_port&quot;: 8888,</span><br><span class="line">    &quot;password&quot;: &quot;dsfad&quot;,</span><br><span class="line">    &quot;timeout&quot;: 600,</span><br><span class="line">    &quot;method&quot;: &quot;rc4-md5&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><blockquote><p>ssserver -c /etc/shadowsocks.json -d start</p></blockquote><h2 id="ss-与-ssr"><a href="#ss-与-ssr" class="headerlink" title="ss 与 ssr"></a>ss 与 ssr</h2><p>以上我们搭建的是ss（shadowsocks）， 目前ss的作者已经不维护了。 而ssr 是ss的增强版本， 下次搭建科学上网的时候可以考虑使用该工具进行搭建。 搭建方法参考如下链接：</p><p><a href="https://wxnacy.com/2019/02/07/linux-install-ssr/#more" target="_blank" rel="noopener">https://wxnacy.com/2019/02/07/linux-install-ssr/#more</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;centos 6.65&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;安装python： &lt;blockquote&gt;
&lt;p&gt;yum install python-setuptools&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;安装wget：&lt;blockquote&gt;
&lt;p&gt;yum install wget&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;安装pip：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -xzvf pip-1.3.1.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd pip-1.3.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;python setup.py install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可直接使用 easy_install pip&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.readytran.com/tags/linux/"/>
    
      <category term="工具" scheme="http://blog.readytran.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>年度总结与来年展望</title>
    <link href="http://blog.readytran.com/2019/01/24/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9D%A5%E5%B9%B4%E5%B1%95%E6%9C%9B/"/>
    <id>http://blog.readytran.com/2019/01/24/年度总结与来年展望/</id>
    <published>2019-01-24T15:33:10.000Z</published>
    <updated>2019-03-11T07:22:14.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018年度总结"><a href="#2018年度总结" class="headerlink" title="2018年度总结"></a>2018年度总结</h3><p>2018年已经过去了，2019的春节也在下周就要进入回老家过年模式了。2018年公司业绩持续下滑，工资也发不起，在这样的背景下<span style="background-color: yellow;">CEO &amp; CTO </span>突然宣布要单干，弄下一堆龌龊事，丢下一堆没交接的工作让我们剩下的人去摸索，个中详情堪比宫斗。具体情况也就不多言了，是枭雄也好，是小人也罢，都让它留在2018的岁月里，2018的人生经历中<a id="more"></a></p><p>回顾在他领导的公司文化下工作的这将近四年，觉得自己真是脑子秀逗。<span style="background-color: yellow;">公司管理混乱；ceo脾气暴躁，动辄咆哮；技术不被认可；做着边缘工作，技术得不到提升；经常要加班到很晚，经常要凌晨两三点起床做技术support；</span>就这样的环境我呆了四年，刚开始的时候居然还能满怀激情，在别人发着大把奖金的情况下我也能心平气和。现在回头想想，只是因为老板会画饼，因为给我0.5的股份承诺，让我将公司当成了一个可以长远发展的平台。事实证明，如果自身能力得不到提升，一切都是虚妄,别人想抛弃你就抛弃你。</p><p>其实回顾这工作的10年来， 我都在自己作，没有长远的规划，从来也没想过要进大公司，都是在得过且过，每思及此， 都要顿首懊恼。 往事已经不可追， 未来仍要期。 未来需要努力提升自己，从身体上，修养上，知识技能上。</p><h3 id="2019年度计划"><a href="#2019年度计划" class="headerlink" title="2019年度计划"></a>2019年度计划</h3><p>2019年需要努力提升自己的技能包。希望下一个10年从2019做起，即使不能富贵也需要拒绝做中年油腻男，拒绝做被别人调侃的对象。以下为2019年的年度学习，生活计划。时间：~2010-01-01</p><ul><li>每周学习100个以上英语单词 （25*4+）</li><li>码农沉淀计划 - 每周三篇以上gitpage博客。 内容主要为：<blockquote><p>英语系列， 面试题目系列， 设计模式系列， jvm系列， linux系列</p></blockquote></li><li>找一份比较满意的工作</li><li>博客园开通博客，写一些高质量博客</li><li>开通个人服务号，打造个人品牌</li><li>阅读8本技术书籍</li><li>带着我的大小宝贝出门旅游</li><li>每周至少健身一次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018年度总结&quot;&gt;&lt;a href=&quot;#2018年度总结&quot; class=&quot;headerlink&quot; title=&quot;2018年度总结&quot;&gt;&lt;/a&gt;2018年度总结&lt;/h3&gt;&lt;p&gt;2018年已经过去了，2019的春节也在下周就要进入回老家过年模式了。2018年公司业绩持续下滑，工资也发不起，在这样的背景下&lt;span style=&quot;background-color: yellow;&quot;&gt;CEO &amp;amp; CTO &lt;/span&gt;突然宣布要单干，弄下一堆龌龊事，丢下一堆没交接的工作让我们剩下的人去摸索，个中详情堪比宫斗。具体情况也就不多言了，是枭雄也好，是小人也罢，都让它留在2018的岁月里，2018的人生经历中
    
    </summary>
    
    
      <category term="主页" scheme="http://blog.readytran.com/tags/%E4%B8%BB%E9%A1%B5/"/>
    
      <category term="年度总结" scheme="http://blog.readytran.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>关于https证书</title>
    <link href="http://blog.readytran.com/2019/01/15/%E5%85%B3%E4%BA%8Ehttps%E8%AF%81%E4%B9%A6/"/>
    <id>http://blog.readytran.com/2019/01/15/关于https证书/</id>
    <published>2019-01-15T15:24:38.000Z</published>
    <updated>2019-02-18T08:44:39.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于https证书"><a href="#关于https证书" class="headerlink" title="关于https证书"></a>关于https证书</h1><ul><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</li></ul><blockquote><p>苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App Transport Security安全功能。App Transport Security（ATS）是苹果在iOS 9中引入的一项隐私保护功能，屏蔽明文HTTP资源加载，连接必须经过更安全的HTTPS。苹果目前允许开发者暂时关闭ATS，可以继续使用HTTP连接，但到年底所有官方商店的应用都必须强制性使用ATS.<br><br>所以，推行https是整个互联网行业的趋势.<br><a id="more"></a></p></blockquote><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><blockquote><p>目前主流的SSL证书主要分为DV SSL 、 OV SSL 、EV SSL</p></blockquote><h2 id="DV-SSL"><a href="#DV-SSL" class="headerlink" title="DV SSL"></a>DV SSL</h2><p>DV SSL证书是只验证网站域名所有权的简易型（Class 1级）SSL证书，可10分钟快速颁发，能起到加密传输的作用，但无法向用户证明网站的真实身份。<br>目前市面上的免费证书都是这个类型的，只是提供了对数据的加密，但是对提供证书的个人和机构的身份不做验证。</p><h2 id="OV-SSL"><a href="#OV-SSL" class="headerlink" title="OV SSL"></a>OV SSL</h2><p>OV SSL,提供加密功能,对申请者做严格的身份审核验证,提供可信身份证明。<br>和DV SSL的区别在于，OV SSL 提供了对个人或者机构的审核，能确认对方的身份，安全性更高。<br>所以这部分的证书申请是收费的~</p><h2 id="EV-SSL"><a href="#EV-SSL" class="headerlink" title="EV SSL"></a>EV SSL</h2><p>超安=EV=最安全、最严格 超安EV SSL证书遵循全球统一的严格身份验证标准，是目前业界安全级别最高的顶级 (Class 4级)SSL证书。<br>金融证券、银行、第三方支付、网上商城等，重点强调网站安全、企业可信形象的网站，涉及交易支付、客户隐私信息和账号密码的传输。<br>这部分的验证要求最高，申请费用也是最贵的。</p><h1 id="常见的颁发证书机构"><a href="#常见的颁发证书机构" class="headerlink" title="常见的颁发证书机构"></a>常见的颁发证书机构</h1><ul><li>赛门铁克(Symantec)是 SSL/TLS 证书的领先提供商</li><li>中国金融认证中心(CFCA)全球信任SSL证书</li><li>GeoTrust是全球第二大数字证书颁发机构</li><li></li></ul><blockquote><p>转自： <a href="https://www.cnblogs.com/Javi/p/6479577.html" target="_blank" rel="noopener">https://www.cnblogs.com/Javi/p/6479577.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于https证书&quot;&gt;&lt;a href=&quot;#关于https证书&quot; class=&quot;headerlink&quot; title=&quot;关于https证书&quot;&gt;&lt;/a&gt;关于https证书&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;https协议需要到ca申请证书，一般免费证书很少，需要交费。&lt;/li&gt;
&lt;li&gt;http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。&lt;/li&gt;
&lt;li&gt;http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。&lt;/li&gt;
&lt;li&gt;http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App Transport Security安全功能。App Transport Security（ATS）是苹果在iOS 9中引入的一项隐私保护功能，屏蔽明文HTTP资源加载，连接必须经过更安全的HTTPS。苹果目前允许开发者暂时关闭ATS，可以继续使用HTTP连接，但到年底所有官方商店的应用都必须强制性使用ATS.&lt;br&gt;&lt;br&gt;所以，推行https是整个互联网行业的趋势.&lt;br&gt;
    
    </summary>
    
    
      <category term="主页" scheme="http://blog.readytran.com/tags/%E4%B8%BB%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>python与java这对好基友</title>
    <link href="http://blog.readytran.com/2018/10/31/python%E4%B8%8Ejava%E8%BF%99%E5%AF%B9%E5%A5%BD%E5%9F%BA%E5%8F%8B/"/>
    <id>http://blog.readytran.com/2018/10/31/python与java这对好基友/</id>
    <published>2018-10-31T09:00:06.000Z</published>
    <updated>2019-01-24T09:17:06.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h1><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ol><li>都是面向对象</li><li>都可以跨平台</li><li>都是开源的</li><li>都是强类型语言：类型一旦决定了就不能随意更改。 比如 “3”+2，这是错误的。</li></ol><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><a id="more"></a><ol><li>python是全动态性的，可在运行时随时修改代码。 java则不行，tomcat的热部署也是tomcat额外实现的。java的变量是静态的，需要先声明再使用，而python是动态的，不需要提前声明。</li><li>python库很强大，不仅可以使用python，还可以使用C,C++设计，然后给python使用。java库相对没那么强大。</li><li>java运行效率高于python</li><li>java开发偏向于软件工程，团队协同。python则适合快速开发，小型团队。</li><li>java直接通过java虚拟机解释执行字节码（java字节码的设计使得它很容易转成机器码），python需要先编译成中间码，再解释成机器码。</li></ol><h1 id="python的一些特性"><a href="#python的一些特性" class="headerlink" title="python的一些特性"></a>python的一些特性</h1><h2 id="python的GIL"><a href="#python的GIL" class="headerlink" title="python的GIL"></a>python的GIL</h2><blockquote><p>每个线程在执行的过程中需要先获取GIL，保证同一时刻只能有一个线程在运行。</p></blockquote><p>通过以上描述，我们可以看出python不具备并行特性，所以它的并发需要通过多进程的部署方式来提升，以便充分利用多核cpu。</p><p>全局解释器锁，由于cPython虚拟机的原因，导致python的GIL难以移除，和python语言其实没有多少关系。如果想绕过这个限制，可以使用其他解释器，比如jpython，IronPython</p><h2 id="python为什么不像java那样需要定义接口"><a href="#python为什么不像java那样需要定义接口" class="headerlink" title="python为什么不像java那样需要定义接口"></a>python为什么不像java那样需要定义接口</h2><blockquote><p>python的动态性以及多继承特性使得它不需要接口。 而java的变量是静态的，也不支持多继承，所以java需要接口来增加它的扩展性</p></blockquote><p>因为python的变量是动态的，所以你无论参数传的是何种类型，都不会导致程序发生错误无法运行。传的是cat也好，dog也好，后端都可以很好的执行该对象的行为。</p><h1 id="python视频资料《疯狂的python》"><a href="#python视频资料《疯狂的python》" class="headerlink" title="python视频资料《疯狂的python》"></a>python视频资料《疯狂的python》</h1><blockquote><p>链接：<a href="https://pan.baidu.com/s/1brciek-xekinQVWlNrJaXw" target="_blank" rel="noopener">https://pan.baidu.com/s/1brciek-xekinQVWlNrJaXw</a><br>提取码：r4ip </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异同&quot;&gt;&lt;a href=&quot;#异同&quot; class=&quot;headerlink&quot; title=&quot;异同&quot;&gt;&lt;/a&gt;异同&lt;/h1&gt;&lt;h2 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class=&quot;headerlink&quot; title=&quot;共同点&quot;&gt;&lt;/a&gt;共同点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;都是面向对象&lt;/li&gt;
&lt;li&gt;都可以跨平台&lt;/li&gt;
&lt;li&gt;都是开源的&lt;/li&gt;
&lt;li&gt;都是强类型语言：类型一旦决定了就不能随意更改。 比如 “3”+2，这是错误的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;
    
    </summary>
    
    
      <category term="主页" scheme="http://blog.readytran.com/tags/%E4%B8%BB%E9%A1%B5/"/>
    
      <category term="python" scheme="http://blog.readytran.com/tags/python/"/>
    
      <category term="java" scheme="http://blog.readytran.com/tags/java/"/>
    
  </entry>
  
</feed>
